local lib = {}
lib.exec = {}
function lib.find(c)
    for i,v in pairs(lib.exec) do
        if i == c then
            return true
        end
    end
    return false
end
function lib.exec.edit(...)
    local tArgs = { ... }
    if #tArgs == 0 then
        print("Usage: edit <path>")
        return
    end

    local sPath = shell.resolve(tArgs[1])
    local bReadOnly = fs.isReadOnly(sPath)
    if fs.exists(sPath) and fs.isDir(sPath) then
        print("Cannot edit a directory.")
        return
    end

    if not fs.exists(sPath) and not string.find(sPath, "%.") then
        local sExtension = settings.get("edit.default_extension")
        if sExtension ~= "" and type(sExtension) == "string" then
            sPath = sPath .. "." .. sExtension
        end
    end

    local x, y = 1, 1
    local w, h = term.getSize()
    local scrollX, scrollY = 0, 0

    local tLines = {}
    local bRunning = true

    local highlightColour, keywordColour, commentColour, textColour, bgColour, stringColour, errorColour
    bgColour = colours.black
    textColour = colours.white
    highlightColour = colours.blue
    keywordColour = colours.cyan
    commentColour = colours.green
    stringColour = colours.orange
    errorColour = colours.red


    local runHandler = [[multishell.setTitle(multishell.getCurrent(), %q)
    local current = term.current()
    local contents, name = %q, %q
    local fn, err = load(contents, name, nil, _ENV)
    if fn then
        local exception = require "cc.internal.exception"
        local ok, err, co = exception.try(fn, ...)

        term.redirect(current)
        term.setTextColor(term.isColour() and colours.yellow or colours.white)
        term.setBackgroundColor(colours.black)
        term.setCursorBlink(false)

        if not ok then
            printError(err)
            exception.report(err, co, { [name] = contents })
        end
    else
        local parser = require "cc.internal.syntax"
        if parser.parse_program(contents) then printError(err) end
    end

    local message = "Press any key to continue."
    if ok then message = "Program finished. " .. message end
    local _, y = term.getCursorPos()
    local w, h = term.getSize()
    local wrapped = require("cc.strings").wrap(message, w)

    local start_y = h - #wrapped + 1
    if y >= start_y then term.scroll(y - start_y + 1) end
    for i = 1, #wrapped do
        term.setCursorPos(1, start_y + i - 1)
        term.write(wrapped[i])
    end
    os.pullEvent('key')
    require "cc.internal.event".discard_char()
    ]]

    local bMenu = false
    local nMenuItem = 1
    local tMenuItems = {}
    if not bReadOnly then
        table.insert(tMenuItems, "Save")
    end
    if shell.openTab then
        table.insert(tMenuItems, "Run")
    end
    if peripheral.find("printer") then
        table.insert(tMenuItems, "Print")
    end
    table.insert(tMenuItems, "Exit")

    local status_ok, status_text
    local function set_status(text, ok)
        status_ok = ok ~= false
        status_text = text
    end

    if bReadOnly then
        set_status("File is read only", false)
    elseif fs.getFreeSpace(sPath) < 1024 then
        set_status("Disk is low on space", false)
    else
        local message
        message = "Press Ctrl or click here to access menu"
        if #message > w - 5 then
            message = "Press Ctrl for menu"
        end

        set_status(message)
    end

    local function load(_sPath)
        tLines = {}
        if fs.exists(_sPath) then
            local file = io.open(_sPath, "r")
            local sLine = file:read()
            while sLine do
                table.insert(tLines, sLine)
                sLine = file:read()
            end
            file:close()
        end

        if #tLines == 0 then
            table.insert(tLines, "")
        end
    end

    local function save(_sPath, fWrite)
        local sDir = _sPath:sub(1, _sPath:len() - fs.getName(_sPath):len())
        if not fs.exists(sDir) then
            fs.makeDir(sDir)
        end

        local file, fileerr
        local function innerSave()
            file, fileerr = fs.open(_sPath, "w")
            if file then
                if file then
                    fWrite(file)
                end
            else
                error("Failed to open " .. _sPath)
            end
        end

        local ok, err = pcall(innerSave)
        if file then
            file.close()
        end
        return ok, err, fileerr
    end

    local tKeywords = {
        ["and"] = true,
        ["break"] = true,
        ["do"] = true,
        ["else"] = true,
        ["elseif"] = true,
        ["end"] = true,
        ["false"] = true,
        ["for"] = true,
        ["function"] = true,
        ["if"] = true,
        ["in"] = true,
        ["local"] = true,
        ["nil"] = true,
        ["not"] = true,
        ["or"] = true,
        ["repeat"] = true,
        ["return"] = true,
        ["then"] = true,
        ["true"] = true,
        ["until"] = true,
        ["while"] = true,
    }

    local function tryWrite(sLine, regex, colour)
        local match = string.match(sLine, regex)
        if match then
            if type(colour) == "number" then
                term.setTextColour(colour)
            else
                term.setTextColour(colour(match))
            end
            term.write(match)
            term.setTextColour(textColour)
            return string.sub(sLine, #match + 1)
        end
        return nil
    end

    local function writeHighlighted(sLine)
        while #sLine > 0 do
            sLine =
                tryWrite(sLine, "^%-%-%[%[.-%]%]", commentColour) or
                tryWrite(sLine, "^%-%-.*", commentColour) or
                tryWrite(sLine, "^\"\"", stringColour) or
                tryWrite(sLine, "^\".-[^\\]\"", stringColour) or
                tryWrite(sLine, "^\'\'", stringColour) or
                tryWrite(sLine, "^\'.-[^\\]\'", stringColour) or
                tryWrite(sLine, "^%[%[.-%]%]", stringColour) or
                tryWrite(sLine, "^[%w_]+", function(match)
                    if tKeywords[match] then
                        return keywordColour
                    end
                    return textColour
                end) or
                tryWrite(sLine, "^[^%w_]", textColour)
        end
    end

    local tCompletions
    local nCompletion

    local tCompleteEnv = _ENV
    local function complete(sLine)
        if settings.get("edit.autocomplete") then
            local nStartPos = string.find(sLine, "[a-zA-Z0-9_%.:]+$")
            if nStartPos then
                sLine = string.sub(sLine, nStartPos)
            end
            if #sLine > 0 then
                return textutils.complete(sLine, tCompleteEnv)
            end
        end
        return nil
    end

    local function recomplete()
        local sLine = tLines[y]
        if not bMenu and not bReadOnly and x == #sLine + 1 then
            tCompletions = complete(sLine)
            if tCompletions and #tCompletions > 0 then
                nCompletion = 1
            else
                nCompletion = nil
            end
        else
            tCompletions = nil
            nCompletion = nil
        end
    end

    local function writeCompletion(sLine)
        if nCompletion then
            local sCompletion = tCompletions[nCompletion]
            term.setTextColor(colours.white)
            term.setBackgroundColor(colours.grey)
            term.write(sCompletion)
            term.setTextColor(textColour)
            term.setBackgroundColor(bgColour)
        end
    end

    local function redrawText()
        local cursorX, cursorY = x, y
        for y = 1, h - 1 do
            term.setCursorPos(1 - scrollX, y)
            term.clearLine()

            local sLine = tLines[y + scrollY]
            if sLine ~= nil then
                writeHighlighted(sLine)
                if cursorY == y and cursorX == #sLine + 1 then
                    writeCompletion()
                end
            end
        end
        term.setCursorPos(x - scrollX, y - scrollY)
    end

    local function redrawLine(_nY)
        local sLine = tLines[_nY]
        if sLine then
            term.setCursorPos(1 - scrollX, _nY - scrollY)
            term.clearLine()
            writeHighlighted(sLine)
            if _nY == y and x == #sLine + 1 then
                writeCompletion()
            end
            term.setCursorPos(x - scrollX, _nY - scrollY)
        end
    end

    local function redrawMenu()
        term.setCursorPos(1, h)
        term.clearLine()

        term.setCursorPos(w - #("Ln " .. y) + 1, h)
        term.setTextColour(highlightColour)
        term.write("Ln ")
        term.setTextColour(textColour)
        term.write(y)

        term.setCursorPos(1, h)
        if bMenu then
            term.setTextColour(textColour)
            for nItem, sItem in pairs(tMenuItems) do
                if nItem == nMenuItem then
                    term.setTextColour(highlightColour)
                    term.write("[")
                    term.setTextColour(textColour)
                    term.write(sItem)
                    term.setTextColour(highlightColour)
                    term.write("]")
                    term.setTextColour(textColour)
                else
                    term.write(" " .. sItem .. " ")
                end
            end
        else
            term.setTextColour(status_ok and highlightColour or errorColour)
            term.write(status_text)
            term.setTextColour(textColour)
        end

        term.setCursorPos(x - scrollX, y - scrollY)
    end

    local tMenuFuncs = {
        Save = function()
            if bReadOnly then
                set_status("Access denied", false)
            else
                local ok, _, fileerr  = save(sPath, function(file)
                    for _, sLine in ipairs(tLines) do
                        file.write(sLine .. "\n")
                    end
                end)
                if ok then
                    set_status("Saved to " .. sPath)
                else
                    if fileerr then
                        set_status("Error saving: " .. fileerr, false)
                    else
                        set_status("Error saving to " .. sPath, false)
                    end
                end
            end
            redrawMenu()
        end,
        Print = function()
            local printer = peripheral.find("printer")
            if not printer then
                set_status("No printer attached", false)
                return
            end

            local nPage = 0
            local sName = fs.getName(sPath)
            if printer.getInkLevel() < 1 then
                set_status("Printer out of ink", false)
                return
            elseif printer.getPaperLevel() < 1 then
                set_status("Printer out of paper", false)
                return
            end

            local screenTerminal = term.current()
            local printerTerminal = {
                getCursorPos = printer.getCursorPos,
                setCursorPos = printer.setCursorPos,
                getSize = printer.getPageSize,
                write = printer.write,
            }
            printerTerminal.scroll = function()
                if nPage == 1 then
                    printer.setPageTitle(sName .. " (page " .. nPage .. ")")
                end

                while not printer.newPage() do
                    if printer.getInkLevel() < 1 then
                        set_status("Printer out of ink, please refill", false)
                    elseif printer.getPaperLevel() < 1 then
                        set_status("Printer out of paper, please refill", false)
                    else
                        set_status("Printer output tray full, please empty", false)
                    end

                    term.redirect(screenTerminal)
                    redrawMenu()
                    term.redirect(printerTerminal)

                    sleep(0.5)
                end

                nPage = nPage + 1
                if nPage == 1 then
                    printer.setPageTitle(sName)
                else
                    printer.setPageTitle(sName .. " (page " .. nPage .. ")")
                end
            end

            bMenu = false
            term.redirect(printerTerminal)
            local ok, error = pcall(function()
                term.scroll()
                for _, sLine in ipairs(tLines) do
                    print(sLine)
                end
            end)
            term.redirect(screenTerminal)
            if not ok then
                print(error)
            end

            while not printer.endPage() do
                set_status("Printer output tray full, please empty")
                redrawMenu()
                sleep(0.5)
            end
            bMenu = true

            if nPage > 1 then
                set_status("Printed " .. nPage .. " Pages")
            else
                set_status("Printed 1 Page")
            end
            redrawMenu()
        end,
        Exit = function()
            bRunning = false
        end,
        Run = function()
            local sTitle = fs.getName(sPath)
            if sTitle:sub(-4) == ".lua" then
                sTitle = sTitle:sub(1, -5)
            end
            local sTempPath = bReadOnly and ".temp." .. sTitle or fs.combine(fs.getDir(sPath), ".temp." .. sTitle)
            if fs.exists(sTempPath) then
                set_status("Error saving to " .. sTempPath, false)
                return
            end
            local ok = save(sTempPath, function(file)
                file.write(runHandler:format(sTitle, table.concat(tLines, "\n"), "@/" .. sPath))
            end)
            if ok then
                local nTask = shell.openTab("/" .. sTempPath)
                if nTask then
                    shell.switchTab(nTask)
                else
                    set_status("Error starting Task", false)
                end
                fs.delete(sTempPath)
            else
                set_status("Error saving to " .. sTempPath, false)
            end
            redrawMenu()
        end,
    }

    local function doMenuItem(_n)
        tMenuFuncs[tMenuItems[_n]]()
        if bMenu then
            bMenu = false
            term.setCursorBlink(true)
        end
        redrawMenu()
    end

    local function setCursor(newX, newY)
        local _, oldY = x, y
        x, y = newX, newY
        local screenX = x - scrollX
        local screenY = y - scrollY

        local bRedraw = false
        if screenX < 1 then
            scrollX = x - 1
            screenX = 1
            bRedraw = true
        elseif screenX > w then
            scrollX = x - w
            screenX = w
            bRedraw = true
        end

        if screenY < 1 then
            scrollY = y - 1
            screenY = 1
            bRedraw = true
        elseif screenY > h - 1 then
            scrollY = y - (h - 1)
            screenY = h - 1
            bRedraw = true
        end

        recomplete()
        if bRedraw then
            redrawText()
        elseif y ~= oldY then
            redrawLine(oldY)
            redrawLine(y)
        else
            redrawLine(y)
        end
        term.setCursorPos(screenX, screenY)

        redrawMenu()
    end

    load(sPath)

    term.setBackgroundColour(bgColour)
    term.clear()
    term.setCursorPos(x, y)
    term.setCursorBlink(true)

    recomplete()
    redrawText()
    redrawMenu()

    local function acceptCompletion()
        if nCompletion then
            local sCompletion = tCompletions[nCompletion]
            tLines[y] = tLines[y] .. sCompletion
            setCursor(x + #sCompletion , y)
        end
    end

    while bRunning do
        local sEvent, param, param2, param3 = os.pullEvent()
        if sEvent == "key" then
            if param == keys.up then
                if not bMenu then
                    if nCompletion then
                        nCompletion = nCompletion - 1
                        if nCompletion < 1 then
                            nCompletion = #tCompletions
                        end
                        redrawLine(y)

                    elseif y > 1 then
                        setCursor(
                            math.min(x, #tLines[y - 1] + 1),
                            y - 1
                        )
                    end
                end

            elseif param == keys.down then
                if not bMenu then
                    if nCompletion then
                        nCompletion = nCompletion + 1
                        if nCompletion > #tCompletions then
                            nCompletion = 1
                        end
                        redrawLine(y)

                    elseif y < #tLines then
                        setCursor(
                            math.min(x, #tLines[y + 1] + 1),
                            y + 1
                        )
                    end
                end

            elseif param == keys.tab then
                if not bMenu and not bReadOnly then
                    if nCompletion and x == #tLines[y] + 1 then
                        acceptCompletion()
                    else
                        local sLine = tLines[y]
                        tLines[y] = string.sub(sLine, 1, x - 1) .. "    " .. string.sub(sLine, x)
                        setCursor(x + 4, y)
                    end
                end

            elseif param == keys.pageUp then
                if not bMenu then
                    local newY
                    if y - (h - 1) >= 1 then
                        newY = y - (h - 1)
                    else
                        newY = 1
                    end
                    setCursor(
                        math.min(x, #tLines[newY] + 1),
                        newY
                    )
                end

            elseif param == keys.pageDown then
                if not bMenu then
                    local newY
                    if y + (h - 1) <= #tLines then
                        newY = y + (h - 1)
                    else
                        newY = #tLines
                    end
                    local newX = math.min(x, #tLines[newY] + 1)
                    setCursor(newX, newY)
                end

            elseif param == keys.home then
                if not bMenu then
                    if x > 1 then
                        setCursor(1, y)
                    end
                end

            elseif param == keys["end"] then
                if not bMenu then
                    local nLimit = #tLines[y] + 1
                    if x < nLimit then
                        setCursor(nLimit, y)
                    end
                end

            elseif param == keys.left then
                if not bMenu then
                    if x > 1 then
                        setCursor(x - 1, y)
                    elseif x == 1 and y > 1 then
                        setCursor(#tLines[y - 1] + 1, y - 1)
                    end
                else
                    nMenuItem = nMenuItem - 1
                    if nMenuItem < 1 then
                        nMenuItem = #tMenuItems
                    end
                    redrawMenu()
                end

            elseif param == keys.right then
                if not bMenu then
                    local nLimit = #tLines[y] + 1
                    if x < nLimit then
                        setCursor(x + 1, y)
                    elseif nCompletion and x == #tLines[y] + 1 then
                        acceptCompletion()
                    elseif x == nLimit and y < #tLines then
                        setCursor(1, y + 1)
                    end
                else
                    nMenuItem = nMenuItem + 1
                    if nMenuItem > #tMenuItems then
                        nMenuItem = 1
                    end
                    redrawMenu()
                end

            elseif param == keys.delete then
                if not bMenu and not bReadOnly then
                    local nLimit = #tLines[y] + 1
                    if x < nLimit then
                        local sLine = tLines[y]
                        tLines[y] = string.sub(sLine, 1, x - 1) .. string.sub(sLine, x + 1)
                        recomplete()
                        redrawLine(y)
                    elseif y < #tLines then
                        tLines[y] = tLines[y] .. tLines[y + 1]
                        table.remove(tLines, y + 1)
                        recomplete()
                        redrawText()
                    end
                end

            elseif param == keys.backspace then
                if not bMenu and not bReadOnly then
                    if x > 1 then
                        local sLine = tLines[y]
                        if x > 4 and string.sub(sLine, x - 4, x - 1) == "    " and not string.sub(sLine, 1, x - 1):find("%S") then
                            tLines[y] = string.sub(sLine, 1, x - 5) .. string.sub(sLine, x)
                            setCursor(x - 4, y)
                        else
                            tLines[y] = string.sub(sLine, 1, x - 2) .. string.sub(sLine, x)
                            setCursor(x - 1, y)
                        end
                    elseif y > 1 then
                        local sPrevLen = #tLines[y - 1]
                        tLines[y - 1] = tLines[y - 1] .. tLines[y]
                        table.remove(tLines, y)
                        setCursor(sPrevLen + 1, y - 1)
                        redrawText()
                    end
                end

            elseif param == keys.enter or param == keys.numPadEnter then
                if not bMenu and not bReadOnly then
                    local sLine = tLines[y]
                    local _, spaces = string.find(sLine, "^[ ]+")
                    if not spaces then
                        spaces = 0
                    end
                    tLines[y] = string.sub(sLine, 1, x - 1)
                    table.insert(tLines, y + 1, string.rep(' ', spaces) .. string.sub(sLine, x))
                    setCursor(spaces + 1, y + 1)
                    redrawText()

                elseif bMenu then
                    doMenuItem(nMenuItem)

                end

            elseif param == keys.leftCtrl or param == keys.rightCtrl then
                bMenu = not bMenu
                if bMenu then
                    term.setCursorBlink(false)
                else
                    term.setCursorBlink(true)
                end
                redrawMenu()
            elseif param == keys.rightAlt then
                if bMenu then
                    bMenu = false
                    term.setCursorBlink(true)
                    redrawMenu()
                end
            end

        elseif sEvent == "char" then
            if not bMenu and not bReadOnly then
                local sLine = tLines[y]
                tLines[y] = string.sub(sLine, 1, x - 1) .. param .. string.sub(sLine, x)
                setCursor(x + 1, y)

            elseif bMenu then
                for n, sMenuItem in ipairs(tMenuItems) do
                    if string.lower(string.sub(sMenuItem, 1, 1)) == string.lower(param) then
                        doMenuItem(n)
                        break
                    end
                end
            end

        elseif sEvent == "paste" then
            if not bReadOnly then
                if bMenu then
                    bMenu = false
                    term.setCursorBlink(true)
                    redrawMenu()
                end
                local sLine = tLines[y]
                tLines[y] = string.sub(sLine, 1, x - 1) .. param .. string.sub(sLine, x)
                setCursor(x + #param , y)
            end

        elseif sEvent == "mouse_click" then
            local cx, cy = param2, param3
            if not bMenu then
                if param == 1 then
                    if cy < h then
                        local newY = math.min(math.max(scrollY + cy, 1), #tLines)
                        local newX = math.min(math.max(scrollX + cx, 1), #tLines[newY] + 1)
                        setCursor(newX, newY)
                    else
                        bMenu = true
                        redrawMenu()
                    end
                end
            else
                if cy == h then
                    local nMenuPosEnd = 1
                    local nMenuPosStart = 1
                    for n, sMenuItem in ipairs(tMenuItems) do
                        nMenuPosEnd = nMenuPosEnd + #sMenuItem + 1
                        if cx > nMenuPosStart and cx < nMenuPosEnd then
                            doMenuItem(n)
                        end
                        nMenuPosEnd = nMenuPosEnd + 1
                        nMenuPosStart = nMenuPosEnd
                    end
                else
                    bMenu = false
                    term.setCursorBlink(true)
                    redrawMenu()
                end
            end

        elseif sEvent == "mouse_scroll" then
            if not bMenu then
                if param == -1 then
                    if scrollY > 0 then
                        scrollY = scrollY - 1
                        redrawText()
                    end

                elseif param == 1 then
                    local nMaxScroll = #tLines - (h - 1)
                    if scrollY < nMaxScroll then
                        scrollY = scrollY + 1
                        redrawText()
                    end

                end
            end

        elseif sEvent == "term_resize" then
            w, h = term.getSize()
            setCursor(x, y)
            redrawMenu()
            redrawText()

        end
    end

    term.clear()
    term.setCursorBlink(false)
    term.setCursorPos(1, 1)
end
function lib.exec.exit(...)
    shell.exit()
end
function lib.exec.cd(...)
    local tArgs = { ... }
    if #tArgs < 1 then
        local programName = arg[0] or fs.getName(shell.getRunningProgram())
        print("Usage: cd <path>")
        print("shortcuts:")
        print("    ~ = user's home dir")
        print("    .. = previous dir")
        print("    / = root dir")
        return
    end

    local sNewDir = shell.resolve(tArgs[1])
    if string.sub(tArgs[1],1,1) == "~" then
        if os.username() == "root" then
            shell.cd("root"..string.sub(tArgs[1],2))
        else
            shell.cd("home/"..os.username()..string.sub(tArgs[1],2))
        end
    elseif fs.isDir(sNewDir) then
        shell.cd(sNewDir)
    else
        term.setTextColor(colors.red)
        print("Not a directory")
        term.setTextColor(colors.white)
        return
    end
    return sDir
end
function lib.exec.pwd(...)
    print("/"..shell.dir())
end
function lib.exec.list(...)
    local tArgs = { ... }
    local sDir = shell.dir()
    if tArgs[1] ~= nil then
        sDir = shell.resolve(tArgs[1])
    end
    if not fs.isDir(sDir) then
        printError("Not a directory")
        return
    end
    local tAll = fs.list(sDir)
    local tFiles = {}
    local tDirs = {}
    local bShowHidden = settings.get("list.show_hidden")
    for _, sItem in pairs(tAll) do
        if bShowHidden or string.sub(sItem, 1, 1) ~= "." then
            local sPath = fs.combine(sDir, sItem)
            if fs.isDir(sPath) then
                table.insert(tDirs, sItem)
            else
                table.insert(tFiles, sItem)
            end
        end
    end
    table.sort(tDirs)
    table.sort(tFiles)
    textutils.pagedTabulate(theme.main, tDirs, theme.sec, tFiles)
end
function lib.exec.ls(...)
    lib.exec.list(...)
end
function lib.exec.echo(...)
    local tArgs = { ... }
    if #tArgs < 1 then
        print("Usage: echo [arg] <string>")
        print("Usage: echo <string>")
        return
    end

    local vc = 0

    local function move(ix,iy)
        local x,y = term.getCursorPos()
        if y == 19 then
            term.scroll(iy)
            term.setCursorPos(x+ix,19)
        else
            term.setCursorPos(x+ix,y+iy)
        end
    end

    local function go()
        if tArgs[1] == "-e" then
            for i,v in ipairs(tArgs) do

                if v == "/n" then
                    local x,y = term.getCursorPos()
                    term.setCursorPos(1,y)
                    move(0,1)
                elseif v == "/c" then
                    return "c"
                elseif v == "/b" then
                    move(-1,0)
                elseif v == "/t" then
                    move(4,0)
                elseif v == "/v" then
                    vc = vc+1
                    local x,y = term.getCursorPos()
                    term.setCursorPos(1,y)
                    move(vc*4,1)
                elseif i == 1 then
                    --remove arg
                else
                    term.write(v.." ")
                end
            end
        elseif tArgs[1] == "-n" then
            for i,v in ipairs(tArgs) do
                if i == 1 then
                    --remove arg
                else
                    term.write(v.." ")
                end
            end
            return "c"
        elseif tArgs[1] == "*" then
            for i,v in ipairs(tArgs) do
                if i == 1 then
                    --remove arg
                else
                    textutils.pagedTabulate(fs.list(shell.dir()))
                end
            end
        else
            for i,v in ipairs(tArgs) do
                term.write(v.." ")
            end
        end
    end

    local x,y = term.getCursorPos()
    if go() == nil then
        local x,y = term.getCursorPos()
        term.setCursorPos(1,y)
        move(0,1)
    end
end
function lib.exec.lua(...)
    local tArgs = { ... }
    if #tArgs > 0 then
        print("This is an interactive Lua prompt.")
        print("To run a lua program, just type its name.")
        return
    end

    local pretty = require "pretty"
    local exception = require "internal.exception"

    local running = true
    local tCommandHistory = {}
    local tEnv = {
        ["exit"] = setmetatable({}, {
            __tostring = function() return "Type exit() to exit" end,
            __call = function() running = false end,
        }),
        ["_echo"] = function(...)
            return ...
        end,
    }
    setmetatable(tEnv, { __index = _ENV })

    -- Replace our require with new instance that loads from the current directory
    -- rather than from /rom/programs. This makes it more friendly to use and closer
    -- to what you'd expect.
    do
        local make_package = require "require".make
        local dir = shell.dir()
        _ENV.require, _ENV.package = make_package(_ENV, dir)
    end

    if term.isColour() then
        term.setTextColour(colours.blue)
    end
    print("Interactive Lua prompt.")
    print("Call exit() to exit.")
    term.setTextColour(colours.white)

    local chunk_idx, chunk_map = 1, {}
    while running do
        if term.isColour() then
            term.setTextColour( colors.green )
        end
        write("lua: ")
        term.setTextColour( colours.white )

        local input = read(nil, tCommandHistory, function(sLine)
            if settings.get("lua.autocomplete") then
                local nStartPos = string.find(sLine, "[a-zA-Z0-9_%.:]+$")
                if nStartPos then
                    sLine = string.sub(sLine, nStartPos)
                end
                if #sLine > 0 then
                    return textutils.complete(sLine, tEnv)
                end
            end
            return nil
        end)
        if input:match("%S") and tCommandHistory[#tCommandHistory] ~= input then
            table.insert(tCommandHistory, input)
        end
        if settings.get("lua.warn_against_use_of_local") and input:match("^%s*local%s+") then
            if term.isColour() then
                term.setTextColour(colours.yellow)
            end
           print("To access local variables in later inputs, remove the local keyword.")
           term.setTextColour(colours.white)
        end

        local name, offset = "=lua[" .. chunk_idx .. "]", 0

        local func, err = load(input, name, "t", tEnv)
        if load("return " .. input) then
            -- We wrap the expression with a call to _echo(...), which prevents tail
            -- calls (and thus confusing errors). Note we check this is a valid
            -- expression separately, to avoid accepting inputs like `)--` (which are
            -- parsed as `_echo()--)`.
            func = load("return _echo(" .. input .. "\n)", name, "t", tEnv)
            offset = 13
        end

        if func then
            chunk_map[name] = { contents = input, offset = offset }
            chunk_idx = chunk_idx + 1

            local results = table.pack(exception.try(func))
            if results[1] then
                for i = 2, results.n do
                    local value = results[i]
                    local ok, serialised = pcall(pretty.pretty, value, {
                        function_args = settings.get("lua.function_args"),
                        function_source = settings.get("lua.function_source"),
                    })
                    if ok then
                        pretty.print(serialised)
                    else
                        print(tostring(value))
                    end
                end
            else
                printError(results[2])
                exception.report(results[2], results[3], chunk_map)
            end
        else
            local parser = require "internal.syntax.init"
            if parser.parse_repl(input) then printError(err) end
        end
    end
end
function lib.exec.copy(...)
    local tArgs = { ... }
    if #tArgs < 2 then
        print("Usage: copy <source> <destination>")
        print("Usage: cp <source> <destination>")
        return
    end

    local sSource = shell.resolve(tArgs[1])
    local sDest = shell.resolve(tArgs[2])
    local tFiles = fs.find(sSource)
    if #tFiles > 0 then
        for _, sFile in ipairs(tFiles) do
            if fs.isDir(sDest) then
                fs.copy(sFile, fs.combine(sDest, fs.getName(sFile)))
            elseif #tFiles == 1 then
                if fs.exists(sDest) then
                     printError("Destination exists")
                elseif fs.isReadOnly(sDest) then
                    printError("Destination is read-only")
                elseif fs.getFreeSpace(sDest) < fs.getSize(sFile) then
                    printError("Not enough space")
                else
                     fs.copy(sFile, sDest)
                end
            else
                printError("Cannot overwrite file multiple times")
                return
            end
        end
    else
        printError("No matching files")
    end
end
function lib.exec.cp(...)
    lib.exec.copy(...)
end
function lib.exec.wget(...)
    local function printUsage()
        local programName = arg[0] or fs.getName(shell.getRunningProgram())
        print("Usage:")
        print("wget <url> [filename]")
        print("wget run <url>")
    end
    
    local tArgs = { ... }
    
    local run = false
    if tArgs[1] == "run" then
        table.remove(tArgs, 1)
        run = true
    end
    
    if #tArgs < 1 then
        printUsage()
        return
    end
    
    local url = table.remove(tArgs, 1)
    
    if not http then
        printError("wget requires the http API, but it is not enabled")
        printError("Set http.enabled to true in CC: Tweaked's server config")
        return
    end
    
    local function getFilename(sUrl)
        sUrl = sUrl:gsub("[#?].*" , ""):gsub("/+$" , "")
        return sUrl:match("/([^/]+)$")
    end
    
    local function get(sUrl)
        -- Check if the URL is valid
        local ok, err = http.checkURL(url)
        if not ok then
            printError(err or "Invalid URL.")
            return
        end
    
        write("Connecting to " .. sUrl .. "... ")
    
        local response = http.get(sUrl)
        if not response then
            print("Failed.")
            return nil
        end
    
        print("Success.")
    
        local sResponse = response.readAll()
        response.close()
        return sResponse or ""
    end
    
    if run then
        local res = get(url)
        if not res then return end
    
        local func, err = load(res, getFilename(url), "t", _ENV)
        if not func then
            printError(err)
            return
        end
    
        local ok, err = pcall(func, table.unpack(tArgs))
        if not ok then
            printError(err)
        end
    else
        local sFile = tArgs[1] or getFilename(url) or url
        local sPath = shell.resolve(sFile)
        if fs.exists(sPath) then
            print("File already exists")
            return
        end
    
        local res = get(url)
        if not res then return end
    
        local file, err = fs.open(sPath, "wb")
        if not file then
            printError("Cannot save file: " .. err)
            return
        end
    
        file.write(res)
        file.close()
    
        print("Downloaded as " .. sFile)
    end
end
function lib.exec.man(...)
    local tArgs = { ... }
    local sTopic
    if #tArgs > 0 then
        sTopic = tArgs[1]
    else
        sTopic = "intro"
    end

    if sTopic == "index" then
        print("Help topics available:")
        local tTopics,_ = pairs(lib.man)
        textutils.pagedTabulate(tTopics)
        return
    end

    local strings = require "strings"

    local function min_of(a, b, default)
        if not a and not b then return default end
        if not a then return b end
        if not b then return a end
        return math.min(a, b)
    end

    --[[- Parse a markdown string, extracting headings and highlighting some basic
    constructs.

    The implementation of this is horrible. SquidDev shouldn't be allowed to write
    parsers, especially ones they think might be "performance critical".
    ]]
    local function parse_markdown(text)
        local len = #text
        local oob = len + 1

        -- Some patterns to match headers and bullets on the start of lines.
        -- The `%f[^\n\0]` is some wonderful logic to match the start of a line /or/
        -- the start of the document.
        local heading = "%f[^\n\0](#+ +)([^\n]*)"
        local bullet = "%f[^\n\0]( *)[.*]( +)"
        local code = "`([^`]+)`"

        local new_text, fg, bg = "", "", ""
        local function append(txt, fore, back)
            new_text = new_text .. txt
            fg = fg .. (fore or "0"):rep(#txt)
            bg = bg .. (back or "f"):rep(#txt)
        end

        local next_header = text:find(heading)
        local next_bullet = text:find(bullet)
        local next_block = min_of(next_header, next_bullet, oob)

        local next_code, next_code_end = text:find(code)

        local sections = {}

        local start = 1
        while start <= len do
            if start == next_block then
                if start == next_header then
                    local _, fin, head, content = text:find(heading, start)
                    sections[#new_text + 1] = content
                    append(head .. content, "4", "f")
                    start = fin + 1

                    next_header = text:find(heading, start)
                else
                    local _, fin, space, content = text:find(bullet, start)
                    append(space .. "\7" .. content)
                    start = fin + 1

                    next_bullet = text:find(bullet, start)
                end

                next_block = min_of(next_header, next_bullet, oob)
            elseif next_code and next_code_end < next_block then
                -- Basic inline code blocks
                if start < next_code then append(text:sub(start, next_code - 1)) end
                local content = text:match(code, next_code)
                append(content, "0", "7")

                start = next_code_end + 1
                next_code, next_code_end = text:find(code, start)
            else
                -- Normal text
                append(text:sub(start, next_block - 1))
                start = next_block

                -- Rescan for a new code block
                if next_code then next_code, next_code_end = text:find(code, start) end
            end
        end

        return new_text, fg, bg, sections
    end

    local function word_wrap_basic(text, width)
        local lines, fg, bg = strings.wrap(text, width), {}, {}
        local fg_line, bg_line = ("0"):rep(width), ("f"):rep(width)

        -- Normalise the strings suitable for use with blit. We could skip this and
        -- just use term.write, but saves us a clearLine call.
        for k, line in pairs(lines) do
            lines[k] = strings.ensure_width(line, width)
            fg[k] = fg_line
            bg[k] = bg_line
        end

        return lines, fg, bg, {}
    end

    local function word_wrap_markdown(text, width)
        -- Add in styling for Markdown-formatted text.
        local text, fg, bg, sections = parse_markdown(text)

        local lines = strings.wrap(text, width)
        local fglines, bglines, section_list, section_n = {}, {}, {}, 1

        -- Normalise the strings suitable for use with blit. We could skip this and
        -- just use term.write, but saves us a clearLine call.
        local start = 1
        for k, line in pairs(lines) do
            -- I hate this with a burning passion, but it works!
            local pos = text:find(line, start, true)
            lines[k], fglines[k], bglines[k] =
                strings.ensure_width(line, width),
                strings.ensure_width(fg:sub(pos, pos + #line), width),
                strings.ensure_width(bg:sub(pos, pos + #line), width)

            if sections[pos] then
                section_list[section_n], section_n = { content = sections[pos], offset = k - 1 }, section_n + 1
            end

            start = pos + 1
        end

        return lines, fglines, bglines, section_list
    end

    local sFile = help.lookup(sTopic)
    local file = sFile ~= nil and io.open(sFile) or nil
    if not file then
        printError("No help available")
        return
    end

    local contents = file:read("*a")
    file:close()
    -- Trim trailing newlines from the file to avoid displaying a blank line.
    if contents:sub(-1) == "\n" then contents:sub(1, -2) end

    local word_wrap = sFile:sub(-3) == ".md" and word_wrap_markdown or word_wrap_basic
    local width, height = term.getSize()
    local content_height = height - 1 -- Height of the content box.
    local lines, fg, bg, sections = word_wrap(contents, width)
    local print_height = #lines

    -- If we fit within the screen, just display without pagination.
    if print_height <= content_height then
        local _, y = term.getCursorPos()
        for i = 1, print_height do
            if y + i - 1 > height then
                term.scroll(1)
                term.setCursorPos(1, height)
            else
                term.setCursorPos(1, y + i - 1)
            end

            term.blit(lines[i], fg[i], bg[i])
        end
        return
    end

    local current_section = nil
    local offset = 0

    --- Find the currently visible section, or nil if this document has no sections.
    --
    -- This could potentially be a binary search, but right now it's not worth it.
    local function find_section()
        for i = #sections, 1, -1 do
            if sections[i].offset <= offset then
                return i
            end
        end
    end

    local function draw_menu()
        term.setTextColor(colors.yellow)
        term.setCursorPos(1, height)
        term.clearLine()

        local tag = "Manual: " .. sTopic
        if current_section then
            tag = tag .. (" (%s)"):format(sections[current_section].content)
        end
        term.write(tag)

        if width >= #tag + 16 then
            term.setCursorPos(width - 14, height)
            term.write("Press Q to exit")
        end
    end


    local function draw()
        for y = 1, content_height do
            term.setCursorPos(1, y)
            if y + offset > print_height then
                -- Should only happen if we resize the terminal to a larger one
                -- than actually needed for the current text.
                term.clearLine()
            else
                term.blit(lines[y + offset], fg[y + offset], bg[y + offset])
            end
        end

        local new_section = find_section()
        if new_section ~= current_section then
            current_section = new_section
            draw_menu()
        end
    end

    draw()
    draw_menu()

    while true do
        local event, param = os.pullEventRaw()
        if event == "key" then
            if param == keys.up and offset > 0 then
                offset = offset - 1
                draw()
            elseif param == keys.down and offset < print_height - content_height then
                offset = offset + 1
                draw()
            elseif param == keys.pageUp and offset > 0 then
                offset = math.max(offset - content_height + 1, 0)
                draw()
            elseif param == keys.pageDown and offset < print_height - content_height then
                offset = math.min(offset + content_height - 1, print_height - content_height)
                draw()
            elseif param == keys.home then
                offset = 0
                draw()
            elseif param == keys.left and current_section and current_section > 1 then
                offset = sections[current_section - 1].offset
                draw()
            elseif param == keys.right and current_section and current_section < #sections then
                offset = sections[current_section + 1].offset
                draw()
            elseif param == keys["end"] then
                offset = print_height - content_height
                draw()
            elseif param == keys.q then
                require "internal.event".discard_char()
                break
            end
        elseif event == "mouse_scroll" then
            if param < 0 and offset > 0 then
                offset = offset - 1
                draw()
            elseif param > 0 and offset <= print_height - content_height then
                offset = offset + 1
                draw()
            end
        elseif event == "term_resize" then
            local new_width, new_height = term.getSize()

            if new_width ~= width then
                lines, fg, bg = word_wrap(contents, new_width)
                print_height = #lines
            end

            width, height = new_width, new_height
            content_height = height - 1
            offset = math.max(math.min(offset, print_height - content_height), 0)
            draw()
            draw_menu()
        elseif event == "terminate" then
            break
        end
    end

    term.setCursorPos(1, 1)
    term.clear()
end
function lib.exec.delete(...)
    local args = table.pack(...)
    if args.n < 1 then
        print("Usage: delete <paths>")
        print("Usage: rm <paths>")
        return
    end
    for i = 1, args.n do
        local files = fs.find(shell.resolve(args[i]))
        if #files > 0 then
            for _, file in ipairs(files) do
                if fs.isReadOnly(file) then
                    printError("Cannot delete read-only file /" .. file)
                elseif fs.isDriveRoot(file) then
                    printError("Cannot delete mount /" .. file)
                    if fs.isDir(file) then
                        print("To delete its contents run rm /" .. fs.combine(file, "*"))
                    end
                else
                    local ok, err = pcall(fs.delete, file)
                    if not ok then
                        printError((err:gsub("^pcall: ", "")))
                    end
                end
            end
        else
            printError(args[i] .. ": No matching files")
        end
    end
end
function lib.exec.rm(...)
    lib.exec.delete(...)
end
function lib.exec.touch(...)
    args = {...}
    for i in args do
        f = fs.open(i,"w")
        f.close()
    end
end
function lib.exec.shell(...)
    dofile("sbin/shell/shell.spr")
end
function lib.exec.sh(...)
    lib.exec.shell(...)
end
return lib