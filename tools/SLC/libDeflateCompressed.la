local a;do local b="1.0.0-release"local c="LibDeflate "..b.." Copyright (C) 2018 Haoqian He.".." License GPLv3+: GNU GPL version 3 or later"if LibStub then local d,e="LibDeflate",-1;local f,g=LibStub:GetLibrary(d,true)if f and g and g>=e then return f else a=LibStub:NewLibrary(d,b)end else a={}end;a._VERSION=b;a._COPYRIGHT=c end;local assert=assert;local error=error;local pairs=pairs;local h=string.byte;local i=string.char;local j=string.find;local k=string.gsub;local l=string.sub;local m=table.concat;local n=table.sort;local tostring=tostring;local type=type;local o={}local p={}local q={}local r={}local s={}local t={}local u={}local v={}local w={}local x={3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258}local y={0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0}local z={[0]=1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577}local A={[0]=0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13}local B={16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15}local C;local D;local E;local F;local G;local H;local I;local J;for K=0,255 do p[K]=i(K)end;do local L=1;for K=0,32 do o[K]=L;L=L*2 end end;for K=1,9 do q[K]={}for M=0,o[K+1]-1 do local N=0;local O=M;for P=1,K do N=N-N%2+((N%2==1 or O%2==1)and 1 or 0)O=(O-O%2)/2;N=N*2 end;q[K][M]=(N-N%2)/2 end end;do local Q=18;local R=16;local S=265;local T=1;for U=3,258 do if U<=10 then r[U]=U+254;t[U]=0 elseif U==258 then r[U]=285;t[U]=0 else if U>Q then Q=Q+R;R=R*2;S=S+4;T=T+1 end;local V=U-Q-1+R/2;r[U]=(V-V%(R/8))/(R/8)+S;t[U]=T;s[U]=V%(R/8)end end end;do u[1]=0;u[2]=1;w[1]=0;w[2]=0;local Q=3;local R=4;local W=2;local T=0;for X=3,256 do if X>R then Q=Q*2;R=R*2;W=W+2;T=T+1 end;u[X]=X<=Q and W or W+1;w[X]=T<0 and 0 or T;if R>=8 then v[X]=(X-R/2-1)%(R/4)end end end;local Y,Z,_,a0,a1;if bit~=nil then Y=bit.band;Z=bit.bnot;_=bit.bxor;a0=bit.blshift;a1=bit.blogic_rshift elseif bit32~=nil then Y=bit32.band;Z=bit32.bnot;_=bit32.bxor;a0=bit32.lshift;a1=bit32.rshift else _=function(Q,R)local a2=0;for K=32,0,-1 do local a3=2^K;local a4=false;local a5=false;if Q==0 then a2=a2+R;break end;if R==0 then a2=a2+Q;break end;if Q>=a3 then a4=true;Q=Q-a3 end;if R>=a3 then a5=true;R=R-a3 end;if not(a4 and a5)and(a4 or a5)then a2=a2+a3 end end;return a2 end;a0=function(a6,a7)local a8=a6*2^a7;return a8%2^32 end;a1=function(a6,a9)local a8=a6/2^a9;return math.floor(a8)end;Y=function(Q,R)local aa,S=1,0;while Q>0 and R>0 do local ab,ac=Q%2,R%2;if ab+ac>1 then S=S+aa end;Q,R,aa=(Q-ab)/2,(R-ac)/2,aa*2 end;return S end;Z=function(ad)return bxor(ad,2^(bits or floor(log(ad,2)))-1)end end;local ae=0xEDB88320;local function af(ag)local ah={}local V=setmetatable({},ah)function ah:__index(ai)local aj=ag(ai)V[ai]=aj;return aj end;return V end;local ak=af(function(K)local al=K;for P=1,8 do local R=Y(al,1)al=a1(al,1)if R==1 then al=_(al,ae)end end;return al end)local function am(an,al)al=Z(al or 0)local ao=a1(al,8)local ap=ak[_(al%256,an)]return Z(_(ao,ap))end;local function aq(ar,al)al=al or 0;for K=1,#ar do al=am(ar:byte(K),al)end;return al end;function a:CRC32(ar,al)if type(ar)=='string'then return aq(ar,al)else return am(ar,al)end end;function a:Adler32(as)if type(as)~="string"then error(("Usage: LibDeflate:Adler32(str):".." 'str' - string expected got '%s'."):format(type(as)),2)end;local at=#as;local K=1;local Q=1;local R=0;while K<=at-15 do local au,av,aw,ax,ay,az,aA,aB,aC,aD,aE,aF,aG,aH,aI,aJ=h(as,K,K+15)R=(R+16*Q+16*au+15*av+14*aw+13*ax+12*ay+11*az+10*aA+9*aB+8*aC+7*aD+6*aE+5*aF+4*aG+3*aH+2*aI+aJ)%65521;Q=(Q+au+av+aw+ax+ay+az+aA+aB+aC+aD+aE+aF+aG+aH+aI+aJ)%65521;K=K+16 end;while K<=at do local ad=h(as,K,K)Q=(Q+ad)%65521;R=(R+Q)%65521;K=K+1 end;return(R*65536+Q)%4294967296 end;local function aK(aL,aM)return aL%4294967296==aM%4294967296 end;function a:CreateDictionary(as,at,aN)if type(as)~="string"then error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):".." 'str' - string expected got '%s'."):format(type(as)),2)end;if type(at)~="number"then error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):".." 'strlen' - number expected got '%s'."):format(type(at)),2)end;if type(aN)~="number"then error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):".." 'adler32' - number expected got '%s'."):format(type(aN)),2)end;if at~=#as then error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):".." 'strlen' does not match the actual length of 'str'.".." 'strlen': %u, '#str': %u .".." Please check if 'str' is modified unintentionally."):format(at,#as))end;if at==0 then error("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):".." 'str' - Empty string is not allowed.",2)end;if at>32768 then error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):".." 'str' - string longer than 32768 bytes is not allowed.".." Got %d bytes."):format(at),2)end;local aO=self:Adler32(as)if not aK(aN,aO)then error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):".." 'adler32' does not match the actual adler32 of 'str'.".." 'adler32': %u, 'Adler32(str)': %u .".." Please check if 'str' is modified unintentionally."):format(aN,aO))end;local aP={}aP.adler32=aN;aP.hash_tables={}aP.string_table={}aP.strlen=at;local aQ=aP.string_table;local aR=aP.hash_tables;aQ[1]=h(as,1,1)aQ[2]=h(as,2,2)if at>=3 then local K=1;local aS=aQ[1]*256+aQ[2]while K<=at-2-3 do local au,av,aw,ax=h(as,K+2,K+5)aQ[K+2]=au;aQ[K+3]=av;aQ[K+4]=aw;aQ[K+5]=ax;aS=(aS*256+au)%16777216;local V=aR[aS]if not V then V={}aR[aS]=V end;V[#V+1]=K-at;K=K+1;aS=(aS*256+av)%16777216;V=aR[aS]if not V then V={}aR[aS]=V end;V[#V+1]=K-at;K=K+1;aS=(aS*256+aw)%16777216;V=aR[aS]if not V then V={}aR[aS]=V end;V[#V+1]=K-at;K=K+1;aS=(aS*256+ax)%16777216;V=aR[aS]if not V then V={}aR[aS]=V end;V[#V+1]=K-at;K=K+1 end;while K<=at-2 do local ad=h(as,K+2)aQ[K+2]=ad;aS=(aS*256+ad)%16777216;local V=aR[aS]if not V then V={}aR[aS]=V end;V[#V+1]=K-at;K=K+1 end end;return aP end;local function aT(aP)if type(aP)~="table"then return false,"'dictionary' - table expected got '%s'.":format(type(aP))end;if type(aP.adler32)~="number"or type(aP.string_table)~="table"or type(aP.strlen)~="number"or aP.strlen<=0 or aP.strlen>32768 or aP.strlen~=#aP.string_table or type(aP.hash_tables)~="table"then return false,"'dictionary' - corrupted dictionary.":format(type(aP))end;return true,""end;local aU={[0]={false,nil,0,0,0},[1]={false,nil,4,8,4},[2]={false,nil,5,18,8},[3]={false,nil,6,32,32},[4]={true,4,4,16,16},[5]={true,8,16,32,32},[6]={true,8,16,128,128},[7]={true,8,32,128,256},[8]={true,32,128,258,1024},[9]={true,32,258,258,4096}}local function aV(as,aW,aP,aX,aY)if type(as)~="string"then return false,"'str' - string expected got '%s'.":format(type(as))end;if aW then local aZ,a_=aT(aP)if not aZ then return false,a_ end end;if aX then local b0=type(aY)if b0~="nil"and b0~="table"then return false,"'configs' - nil or table expected got '%s'.":format(type(aY))end;if b0=="table"then for ai,aj in pairs(aY)do if ai~="level"and ai~="strategy"then return false,"'configs' - unsupported table key in the configs: '%s'.":format(ai)elseif ai=="level"and not aU[aj]then return false,"'configs' - unsupported 'level': %s.":format(tostring(aj))elseif ai=="strategy"and aj~="fixed"and aj~="huffman_only"and aj~="dynamic"then return false,"'configs' - unsupported 'strategy': '%s'.":format(tostring(aj))end end end end;return true,""end;local b1=0;local b2=1;local b3=2;local b4=3;local function b5()local b6=0;local b7=0;local b8=0;local b9=0;local ba={}local bb={}local function bc(O,T)b7=b7+O*o[b8]b8=b8+T;b9=b9+T;if b8>=32 then b6=b6+1;ba[b6]=p[b7%256]..p[(b7-b7%256)/256%256]..p[(b7-b7%65536)/65536%256]..p[(b7-b7%16777216)/16777216%256]local bd=o[32-b8+T]b7=(O-O%bd)/bd;b8=b8-32 end end;local function be(as)for P=1,b8,8 do b6=b6+1;ba[b6]=i(b7%256)b7=(b7-b7%256)/256 end;b8=0;b6=b6+1;ba[b6]=as;b9=b9+#as*8 end;local function bf(bg)if bg==b4 then return b9 end;if bg==b2 or bg==b3 then local bh=(8-b8%8)%8;if b8>0 then b7=b7-o[b8]+o[b8+bh]for P=1,b8,8 do b6=b6+1;ba[b6]=p[b7%256]b7=(b7-b7%256)/256 end;b7=0;b8=0 end;if bg==b3 then b9=b9+bh;return b9 end end;local bi=m(ba)ba={}b6=0;bb[#bb+1]=bi;if bg==b1 then return b9 else return b9,m(bb)end end;return bc,be,bf end;local function bj(bk,bl,bm)bm=bm+1;bk[bm]=bl;local O=bl[1]local bn=bm;local bo=(bn-bn%2)/2;while bo>=1 and bk[bo][1]>O do local V=bk[bo]bk[bo]=bl;bk[bn]=V;bn=bo;bo=(bo-bo%2)/2 end end;local function bp(bk,bm)local bq=bk[1]local bl=bk[bm]local O=bl[1]bk[1]=bl;bk[bm]=bq;bm=bm-1;local bn=1;local br=bn*2;local bs=br+1;while br<=bm do local bt=bk[br]if bs<=bm and bk[bs][1]<bt[1]then local bu=bk[bs]if bu[1]<O then bk[bs]=bl;bk[bn]=bu;bn=bs;br=bn*2;bs=br+1 else break end else if bt[1]<O then bk[br]=bl;bk[bn]=bt;bn=br;br=bn*2;bs=br+1 else break end end end;return bq end;local function bv(bw,bx,by,bz)local bA=0;local bB={}local bC={}for T=1,bz do bA=(bA+(bw[T-1]or 0))*2;bB[T]=bA end;for bD=0,by do local T=bx[bD]if T then bA=bB[T]bB[T]=bA+1;if T<=9 then bC[bD]=q[T][bA]else local N=0;for P=1,T do N=N-N%2+((N%2==1 or bA%2==1)and 1 or 0)bA=(bA-bA%2)/2;N=N*2 end;bC[bD]=(N-N%2)/2 end end end;return bC end;local function bE(Q,R)return Q[1]<R[1]or Q[1]==R[1]and Q[2]<R[2]end;local function bF(bG,bz,by)local bm;local bH=-1;local bI={}local bk={}local bx={}local bJ={}local bw={}local bK=0;for bD,bL in pairs(bG)do bK=bK+1;bI[bK]={bL,bD}end;if bK==0 then return{},{},-1 elseif bK==1 then local bD=bI[1][2]bx[bD]=1;bJ[bD]=0;return bx,bJ,bD else n(bI,bE)bm=bK;for K=1,bm do bk[K]=bI[K]end;while bm>1 do local bM=bp(bk,bm)bm=bm-1;local bN=bp(bk,bm)bm=bm-1;local bO={bM[1]+bN[1],-1,bM,bN}bj(bk,bO,bm)bm=bm+1 end;local bP=0;local bQ={bk[1],0,0,0}local bR=1;local bS=1;bk[1][1]=0;while bS<=bR do local bl=bQ[bS]local T=bl[1]local bD=bl[2]local bt=bl[3]local bu=bl[4]if bt then bR=bR+1;bQ[bR]=bt;bt[1]=T+1 end;if bu then bR=bR+1;bQ[bR]=bu;bu[1]=T+1 end;bS=bS+1;if T>bz then bP=bP+1;T=bz end;if bD>=0 then bx[bD]=T;bH=bD>bH and bD or bH;bw[T]=(bw[T]or 0)+1 end end;if bP>0 then repeat local T=bz-1;while(bw[T]or 0)==0 do T=T-1 end;bw[T]=bw[T]-1;bw[T+1]=(bw[T+1]or 0)+2;bw[bz]=bw[bz]-1;bP=bP-2 until bP<=0;bS=1;for T=bz,1,-1 do local bT=bw[T]or 0;while bT>0 do local bD=bI[bS][2]bx[bD]=T;bT=bT-1;bS=bS+1 end end end;bJ=bv(bw,bx,by,bz)return bx,bJ,bH end end;local function bU(bV,bW,bX,bY)local bZ=0;local b_={}local c0={}local c1=0;local c2={}local c3=nil;local bL=0;bY=bY<0 and 0 or bY;local c4=bW+bY+1;for W=0,c4+1 do local U=W<=bW and(bV[W]or 0)or(W<=c4 and(bX[W-bW-1]or 0)or nil)if U==c3 then bL=bL+1;if U~=0 and bL==6 then bZ=bZ+1;b_[bZ]=16;c1=c1+1;c2[c1]=3;c0[16]=(c0[16]or 0)+1;bL=0 elseif U==0 and bL==138 then bZ=bZ+1;b_[bZ]=18;c1=c1+1;c2[c1]=127;c0[18]=(c0[18]or 0)+1;bL=0 end else if bL==1 then bZ=bZ+1;b_[bZ]=c3;c0[c3]=(c0[c3]or 0)+1 elseif bL==2 then bZ=bZ+1;b_[bZ]=c3;bZ=bZ+1;b_[bZ]=c3;c0[c3]=(c0[c3]or 0)+2 elseif bL>=3 then bZ=bZ+1;local c5=c3~=0 and 16 or(bL<=10 and 17 or 18)b_[bZ]=c5;c0[c5]=(c0[c5]or 0)+1;c1=c1+1;c2[c1]=bL<=10 and bL-3 or bL-11 end;c3=U;if U and U~=0 then bZ=bZ+1;b_[bZ]=U;c0[U]=(c0[U]or 0)+1;bL=0 else bL=1 end end end;return b_,c2,c0 end;local function c6(as,V,c7,c8,c9)local K=c7-c9;while K<=c8-15-c9 do V[K],V[K+1],V[K+2],V[K+3],V[K+4],V[K+5],V[K+6],V[K+7],V[K+8],V[K+9],V[K+10],V[K+11],V[K+12],V[K+13],V[K+14],V[K+15]=h(as,K+c9,K+15+c9)K=K+16 end;while K<=c8-c9 do V[K]=h(as,K+c9,K+c9)K=K+1 end;return V end;local function ca(cb,aQ,aR,cc,cd,c9,aP)local ce=aU[cb]local cf,cg,ch,ci,cj=ce[1],ce[2],ce[3],ce[4],ce[5]local ck=not cf and ch or 2147483646;local cl=cj-cj%4/4;local aS;local cm;local cn;local co=0;if aP then cm=aP.hash_tables;cn=aP.string_table;co=aP.strlen;assert(cc==1)if cd>=cc and co>=2 then aS=cn[co-1]*65536+cn[co]*256+aQ[1]local V=aR[aS]if not V then V={}aR[aS]=V end;V[#V+1]=-1 end;if cd>=cc+1 and co>=1 then aS=cn[co]*65536+aQ[1]*256+aQ[2]local V=aR[aS]if not V then V={}aR[aS]=V end;V[#V+1]=0 end end;aS=(aQ[cc-c9]or 0)*256+(aQ[cc+1-c9]or 0)local cp={}local cq=0;local cr={}local cs={}local ct=0;local cu={}local cv={}local cw=0;local cx={}local cy=0;local cz=false;local cA;local cB;local cC=0;local cD=0;local bS=cc;local cE=cd+(cf and 1 or 0)while bS<=cE do local cF=bS-c9;cA=cC;cB=cD;cC=0;aS=(aS*256+(aQ[cF+2]or 0))%16777216;local cG;local cH;local cI=aR[aS]local cJ;if not cI then cJ=0;cI={}aR[aS]=cI;if cm then cH=cm[aS]cG=cH and#cH or 0 else cG=0 end else cJ=#cI;cH=cI;cG=cJ end;if bS<=cd then cI[cJ+1]=bS end;if cG>0 and bS+2<=cd and(not cf or cA<ch)then local cK=cf and cA>=cg and cl or cj;while cG>=1 and cK>0 do local c3=cH[cG]if bS-c3>32768 then break end;if c3<bS then local M=3;if c3>=-257 then local cL=c3-c9;while M<258 and bS+M<=cd do if aQ[cL+M]==aQ[cF+M]then M=M+1 else break end end else local cL=co+c3;while M<258 and bS+M<=cd do if cn[cL+M]==aQ[cF+M]then M=M+1 else break end end end;if M>cC then cC=M;cD=bS-c3 end;if cC>=ci then break end end;cG=cG-1;cK=cK-1;if cG==0 and c3>0 and cm then cH=cm[aS]cG=cH and#cH or 0 end end end;if not cf then cA,cB=cC,cD end;if(not cf or cz)and(cA>3 or cA==3 and cB<4096)and cC<=cA then local W=r[cA]local cM=t[cA]local cN,cO,cP;if cB<=256 then cN=u[cB]cP=v[cB]cO=w[cB]else cN=16;cO=7;local Q=384;local R=512;while true do if cB<=Q then cP=(cB-R/2-1)%(R/4)break elseif cB<=R then cP=(cB-R/2-1)%(R/4)cN=cN+1;break else cN=cN+2;cO=cO+1;Q=Q*2;R=R*2 end end end;cq=cq+1;cp[cq]=W;cr[W]=(cr[W]or 0)+1;ct=ct+1;cs[ct]=cN;cu[cN]=(cu[cN]or 0)+1;if cM>0 then local cQ=s[cA]cw=cw+1;cv[cw]=cQ end;if cO>0 then cy=cy+1;cx[cy]=cP end;for K=bS+1,bS+cA-(cf and 2 or 1)do aS=(aS*256+(aQ[K-c9+2]or 0))%16777216;if cA<=ck then cI=aR[aS]if not cI then cI={}aR[aS]=cI end;cI[#cI+1]=K end end;bS=bS+cA-(cf and 1 or 0)cz=false elseif not cf or cz then local W=aQ[cf and cF-1 or cF]cq=cq+1;cp[cq]=W;cr[W]=(cr[W]or 0)+1;bS=bS+1 else cz=true;bS=bS+1 end end;cq=cq+1;cp[cq]=256;cr[256]=(cr[256]or 0)+1;return cp,cv,cr,cs,cx,cu end;local function cR(cr,cu)local cS,cT,bW=bF(cr,15,285)local cU,cV,bY=bF(cu,15,29)local cW,c2,cX=bU(cS,bW,cU,bY)local cY,cZ=bF(cX,7,18)local c_=0;for K=1,19 do local bD=B[K]local d0=cY[bD]or 0;if d0~=0 then c_=K end end;c_=c_-4;local d1=bW+1-257;local d2=bY+1-1;if d2<0 then d2=0 end;return d1,d2,c_,cY,cZ,cW,c2,cS,cT,cU,cV end;local function d3(cp,cs,c_,cY,cW,cS,cU)local d4=17;d4=d4+(c_+4)*3;for K=1,#cW do local W=cW[K]d4=d4+cY[W]if W>=16 then d4=d4+(W==16 and 2 or(W==17 and 3 or 7))end end;local d5=0;for K=1,#cp do local W=cp[K]local d6=cS[W]d4=d4+d6;if W>256 then d5=d5+1;if W>264 and W<285 then local d7=y[W-256]d4=d4+d7 end;local cN=cs[d5]local d8=cU[cN]d4=d4+d8;if cN>3 then local cO=(cN-cN%2)/2-1;d4=d4+cO end end end;return d4 end;local function d9(bc,da,cp,cv,cs,cx,d1,d2,c_,cY,cZ,cW,c2,cS,cT,cU,cV)bc(da and 1 or 0,1)bc(2,2)bc(d1,5)bc(d2,5)bc(c_,4)for K=1,c_+4 do local bD=B[K]local d0=cY[bD]or 0;bc(d0,3)end;local db=1;for K=1,#cW do local W=cW[K]bc(cZ[W],cY[W])if W>=16 then local dc=c2[db]bc(dc,W==16 and 2 or(W==17 and 3 or 7))db=db+1 end end;local d5=0;local dd=0;local de=0;for K=1,#cp do local df=cp[K]local bA=cT[df]local d6=cS[df]bc(bA,d6)if df>256 then d5=d5+1;if df>264 and df<285 then dd=dd+1;local dg=cv[dd]local d7=y[df-256]bc(dg,d7)end;local dh=cs[d5]local di=cV[dh]local d8=cU[dh]bc(di,d8)if dh>3 then de=de+1;local cP=cx[de]local cO=(dh-dh%2)/2-1;bc(cP,cO)end end end end;local function dj(cp,cs)local d4=3;local d5=0;for K=1,#cp do local W=cp[K]local d6=E[W]d4=d4+d6;if W>256 then d5=d5+1;if W>264 and W<285 then local d7=y[W-256]d4=d4+d7 end;local cN=cs[d5]d4=d4+5;if cN>3 then local cO=(cN-cN%2)/2-1;d4=d4+cO end end end;return d4 end;local function dk(bc,da,cp,cv,cs,cx)bc(da and 1 or 0,1)bc(1,2)local d5=0;local dd=0;local de=0;for K=1,#cp do local dl=cp[K]local bA=C[dl]local d6=E[dl]bc(bA,d6)if dl>256 then d5=d5+1;if dl>264 and dl<285 then dd=dd+1;local dg=cv[dd]local d7=y[dl-256]bc(dg,d7)end;local cN=cs[d5]local di=G[cN]bc(di,5)if cN>3 then de=de+1;local cP=cx[de]local cO=(cN-cN%2)/2-1;bc(cP,cO)end end end end;local function dm(cc,cd,b9)assert(cd-cc+1<=65535)local d4=3;b9=b9+3;local bh=(8-b9%8)%8;d4=d4+bh;d4=d4+32;d4=d4+(cd-cc+1)*8;return d4 end;local function dn(bc,be,da,as,cc,cd,b9)assert(cd-cc+1<=65535)bc(da and 1 or 0,1)bc(0,2)b9=b9+3;local bh=(8-b9%8)%8;if bh>0 then bc(o[bh]-1,bh)end;local dp=cd-cc+1;bc(dp,16)local dq=255-dp%256+(255-(dp-dp%256)/256)*256;bc(dq,16)be(as:sub(cc,cd))end;local function dr(aY,bc,be,bf,as,aP)local aQ={}local aR={}local da=nil;local cc;local cd;local ds;local b9=bf(b4)local at=#as;local c9;local cb;local dt;if aY then if aY.level then cb=aY.level end;if aY.strategy then dt=aY.strategy end end;if not cb then if at<2048 then cb=7 elseif at>65536 then cb=3 else cb=5 end end;while not da do if not cc then cc=1;cd=64*1024-1;c9=0 else cc=cd+1;cd=cd+32*1024;c9=cc-32*1024-1 end;if cd>=at then cd=at;da=true else da=false end;local cp,cv,cr,cs,cx,cu;local d1,d2,c_,cY,cZ,cW,c2,cS,cT,cU,cV;local du;local dv;local dw;if cb~=0 then c6(as,aQ,cc,cd+3,c9)if cc==1 and aP then local cn=aP.string_table;local dx=aP.strlen;for K=0,-dx+1<-257 and-257 or-dx+1,-1 do aQ[K]=cn[dx+K]end end;if dt=="huffman_only"then cp={}c6(as,cp,cc,cd,cc-1)cv={}cr={}cp[cd-cc+2]=256;for K=1,cd-cc+2 do local W=cp[K]cr[W]=(cr[W]or 0)+1 end;cs={}cx={}cu={}else cp,cv,cr,cs,cx,cu=ca(cb,aQ,aR,cc,cd,c9,aP)end;d1,d2,c_,cY,cZ,cW,c2,cS,cT,cU,cV=cR(cr,cu)du=d3(cp,cs,c_,cY,cW,cS,cU)dv=dj(cp,cs)end;dw=dm(cc,cd,b9)local dy=dw;dy=dv and dv<dy and dv or dy;dy=du and du<dy and du or dy;if cb==0 or dt~="fixed"and dt~="dynamic"and dw==dy then dn(bc,be,da,as,cc,cd,b9)b9=b9+dw elseif dt~="dynamic"and(dt=="fixed"or dv==dy)then dk(bc,da,cp,cv,cs,cx)b9=b9+dv elseif dt=="dynamic"or du==dy then d9(bc,da,cp,cv,cs,cx,d1,d2,c_,cY,cZ,cW,c2,cS,cT,cU,cV)b9=b9+du end;if da then ds=bf(b4)else ds=bf(b1)end;assert(ds==b9)if not da then local M;if aP and cc==1 then M=0;while aQ[M]do aQ[M]=nil;M=M-1 end end;aP=nil;M=1;for K=cd-32767,cd do aQ[M]=aQ[K-c9]M=M+1 end;for ai,V in pairs(aR)do local dz=#V;if dz>0 and cd+1-V[1]>32768 then if dz==1 then else local dA={}local dB=0;for K=2,dz do M=V[K]if cd+1-M<=32768 then dB=dB+1;dA[dB]=M end end;aR[ai]=dA end end end end;if os and os.pullEvent then os.queueEvent("nosleep")os.pullEvent()end end end;local function dC(as,aP,aY)local bc,be,bf=b5()dr(aY,bc,be,bf,as,aP)local b9,dD=bf(b2)local bh=(8-b9%8)%8;return dD,bh end;local function dE(as,aP,aY)local bc,be,bf=b5()local dF=8;local dG=7;local dH=dG*16+dF;bc(dH,8)local dI=aP and 1 or 0;local dJ=2;local dK=dJ*64+dI*32;local dL=31-(dH*256+dK)%31;dK=dK+dL;bc(dK,8)if dI==1 then local aN=aP.adler32;local dM=aN%256;aN=(aN-dM)/256;local dN=aN%256;aN=(aN-dN)/256;local dO=aN%256;aN=(aN-dO)/256;local dP=aN%256;bc(dP,8)bc(dO,8)bc(dN,8)bc(dM,8)end;dr(aY,bc,be,bf,as,aP)bf(b3)local aN=a:Adler32(as)local dP=aN%256;aN=(aN-dP)/256;local dO=aN%256;aN=(aN-dO)/256;local dN=aN%256;aN=(aN-dN)/256;local dM=aN%256;bc(dM,8)bc(dN,8)bc(dO,8)bc(dP,8)local b9,dD=bf(b2)local bh=(8-b9%8)%8;return dD,bh end;function a:CompressDeflate(as,aY)local dQ,dR=aV(as,false,nil,true,aY)if not dQ then error("Usage: LibDeflate:CompressDeflate(str, configs): "..dR,2)end;return dC(as,nil,aY)end;function a:CompressDeflateWithDict(as,aP,aY)local dQ,dR=aV(as,true,aP,true,aY)if not dQ then error("Usage: LibDeflate:CompressDeflateWithDict".."(str, dictionary, configs): "..dR,2)end;return dC(as,aP,aY)end;function a:CompressZlib(as,aY)local dQ,dR=aV(as,false,nil,true,aY)if not dQ then error("Usage: LibDeflate:CompressZlib(str, configs): "..dR,2)end;return dE(as,nil,aY)end;function a:CompressZlibWithDict(as,aP,aY)local dQ,dR=aV(as,true,aP,true,aY)if not dQ then error("Usage: LibDeflate:CompressZlibWithDict".."(str, dictionary, configs): "..dR,2)end;return dE(as,aP,aY)end;local function dS()if os.epoch~=nil then return math.floor(os.epoch("utc")/1000)elseif os.time()<30 then return 0 else return os.time()end end;local function an(a6,R)return Y(a1(a6,R*8),0xFF)end;function a:CompressGzip(as,aY)local dQ,dR=aV(as,false,nil,true,aY)if not dQ then error("Usage: LibDeflate:CompressGzip(str, configs): "..dR,2)end;local a8,dT=dC(as,nil,aY)if a8==nil then return a8,dT end;local V=dS()local dU=0;local al=self:CRC32(as)local U=string.len(as)if aY~=nil and aY.level~=nil then if aY.level==0 then dU=0x04 elseif aY.level==9 then dU=0x02 end end;return i(0x1f,0x8b,8,0,an(V,0),an(V,1),an(V,2),an(V,3),dU,0xFF)..a8 ..i(an(al,0),an(al,1),an(al,2),an(al,3),an(U,0),an(U,1),an(U,2),an(U,3))end;local function dV(dW)local dX=dW;local dY=#dW;local dZ=1;local b8=0;local b7=0;local function d_(T)local bd=o[T]local W;if T<=b8 then W=b7%bd;b7=(b7-W)/bd;b8=b8-T else local e0=o[b8]local dN,dO,dP,e1=h(dX,dZ,dZ+3)b7=b7+((dN or 0)+(dO or 0)*256+(dP or 0)*65536+(e1 or 0)*16777216)*e0;dZ=dZ+4;b8=b8+32-T;W=b7%bd;b7=(b7-W)/bd end;return W end;local function e2(e3,ba,b6)assert(b8%8==0)local e4=b8/8<e3 and b8/8 or e3;for P=1,e4 do local an=b7%256;b6=b6+1;ba[b6]=i(an)b7=(b7-an)/256 end;b8=b8-e4*8;e3=e3-e4;if(dY-dZ-e3+1)*8+b8<0 then return-1 end;for K=dZ,dZ+e3-1 do b6=b6+1;ba[b6]=l(dX,K,K)end;dZ=dZ+e3;return b6 end;local function e5(e6,e7,dy)local W=0;local e8=0;local bS=0;local bL;if dy>0 then if b8<15 and dX then local e0=o[b8]local dN,dO,dP,e1=h(dX,dZ,dZ+3)b7=b7+((dN or 0)+(dO or 0)*256+(dP or 0)*65536+(e1 or 0)*16777216)*e0;dZ=dZ+4;b8=b8+32 end;local bd=o[dy]b8=b8-dy;W=b7%bd;b7=(b7-W)/bd;W=q[dy][W]bL=e6[dy]if W<bL then return e7[W]end;bS=bL;e8=bL*2;W=W*2 end;for T=dy+1,15 do local bit;bit=b7%2;b7=(b7-bit)/2;b8=b8-1;W=bit==1 and W+1-W%2 or W;bL=e6[T]or 0;local e9=W-e8;if e9<bL then return e7[bS+e9]end;bS=bS+bL;e8=e8+bL;e8=e8*2;W=W*2 end;return-10 end;local function ea()return(dY-dZ+1)*8+b8 end;local function eb()local ec=b8%8;local bd=o[ec]b8=b8-ec;b7=(b7-b7%bd)/bd end;return d_,e2,e5,ea,eb end;local function ed(as,aP)local d_,e2,e5,ea,eb=dV(as)local ee={ReadBits=d_,ReadBytes=e2,Decode=e5,ReaderBitlenLeft=ea,SkipToByteBoundary=eb,buffer_size=0,buffer={},result_buffer={},dictionary=aP}return ee end;local function ef(eg,by,bz)local e6={}local dy=bz;for bD=0,by do local T=eg[bD]or 0;dy=T>0 and T<dy and T or dy;e6[T]=(e6[T]or 0)+1 end;if e6[0]==by+1 then return 0,e6,{},0 end;local a7=1;for U=1,bz do a7=a7*2;a7=a7-(e6[U]or 0)if a7<0 then return a7 end end;local eh={}eh[1]=0;for U=1,bz-1 do eh[U+1]=eh[U]+(e6[U]or 0)end;local e7={}for bD=0,by do local T=eg[bD]or 0;if T~=0 then local c9=eh[T]e7[c9]=bD;eh[T]=eh[T]+1 end end;return a7,e6,e7,dy end;local function ei(ee,cS,ej,ek,cU,el,em)local ba,b6,d_,e5,ea,bb=ee.buffer,ee.buffer_size,ee.ReadBits,ee.Decode,ee.ReaderBitlenLeft,ee.result_buffer;local aP=ee.dictionary;local cn;local dx;local en=1;if aP and not ba[0]then cn=aP.string_table;dx=aP.strlen;en=-dx+1;for K=0,-dx+1<-257 and-257 or-dx+1,-1 do ba[K]=p[cn[dx+K] ]end end;repeat local bD=e5(cS,ej,ek)if bD<0 or bD>285 then return-10 elseif bD<256 then b6=b6+1;ba[b6]=p[bD]elseif bD>256 then bD=bD-256;local T=x[bD]T=bD>=8 and T+d_(y[bD])or T;bD=e5(cU,el,em)if bD<0 or bD>29 then return-10 end;local X=z[bD]X=X>4 and X+d_(A[bD])or X;local eo=b6-X+1;if eo<en then return-11 end;if eo>=-257 then for P=1,T do b6=b6+1;ba[b6]=ba[eo]eo=eo+1 end else eo=dx+eo;for P=1,T do b6=b6+1;ba[b6]=p[cn[eo] ]eo=eo+1 end end end;if ea()<0 then return 2 end;if b6>=65536 then bb[#bb+1]=m(ba,"",1,32768)for K=32769,b6 do ba[K-32768]=ba[K]end;b6=b6-32768;ba[b6+1]=nil end until bD==256;ee.buffer_size=b6;return 0 end;local function ep(ee)local ba,b6,d_,e2,ea,eb,bb=ee.buffer,ee.buffer_size,ee.ReadBits,ee.ReadBytes,ee.ReaderBitlenLeft,ee.SkipToByteBoundary,ee.result_buffer;eb()local e3=d_(16)if ea()<0 then return 2 end;local eq=d_(16)if ea()<0 then return 2 end;if e3%256+eq%256~=255 then return-2 end;if(e3-e3%256)/256+(eq-eq%256)/256~=255 then return-2 end;b6=e2(e3,ba,b6)if b6<0 then return 2 end;if b6>=65536 then bb[#bb+1]=m(ba,"",1,32768)for K=32769,b6 do ba[K-32768]=ba[K]end;b6=b6-32768;ba[b6+1]=nil end;ee.buffer_size=b6;return 0 end;local function er(ee)return ei(ee,F,D,7,J,H,5)end;local function es(ee)local d_,e5=ee.ReadBits,ee.Decode;local et=d_(5)+257;local eu=d_(5)+1;local ev=d_(4)+4;if et>286 or eu>30 then return-3 end;local cY={}for K=1,ev do cY[B[K] ]=d_(3)end;local ew,ex,ey,ez=ef(cY,18,7)if ew~=0 then return-4 end;local cS={}local cU={}local bS=0;while bS<et+eu do local bD;local T;bD=e5(ex,ey,ez)if bD<0 then return bD elseif bD<16 then if bS<et then cS[bS]=bD else cU[bS-et]=bD end;bS=bS+1 else T=0;if bD==16 then if bS==0 then return-5 end;if bS-1<et then T=cS[bS-1]else T=cU[bS-et-1]end;bD=3+d_(2)elseif bD==17 then bD=3+d_(3)else bD=11+d_(7)end;if bS+bD>et+eu then return-6 end;while bD>0 do bD=bD-1;if bS<et then cS[bS]=T else cU[bS-et]=T end;bS=bS+1 end end end;if(cS[256]or 0)==0 then return-9 end;local eA,eB,ej,ek=ef(cS,et-1,15)if eA~=0 and(eA<0 or et~=(eB[0]or 0)+(eB[1]or 0))then return-7 end;local eC,eD,el,em=ef(cU,eu-1,15)if eC~=0 and(eC<0 or eu~=(eD[0]or 0)+(eD[1]or 0))then return-8 end;return ei(ee,eB,ej,ek,eD,el,em)end;local function eE(ee)local d_=ee.ReadBits;local da;while not da do da=d_(1)==1;local eF=d_(2)local eG;if eF==0 then eG=ep(ee)elseif eF==1 then eG=er(ee)elseif eF==2 then eG=es(ee)else return nil,-1 end;if eG~=0 then return nil,eG end;if os and os.pullEvent then os.queueEvent("nosleep")os.pullEvent()end end;ee.result_buffer[#ee.result_buffer+1]=m(ee.buffer,"",1,ee.buffer_size)local dD=m(ee.result_buffer)return dD end;local function eH(as,aP)local ee=ed(as,aP)local dD,eG=eE(ee)if not dD then return nil,eG end;local eI=ee.ReaderBitlenLeft()local eJ=(eI-eI%8)/8;return dD,eJ end;local function eK(as,aP)local ee=ed(as,aP)local d_=ee.ReadBits;local dH=d_(8)if ee.ReaderBitlenLeft()<0 then return nil,2 end;local dF=dH%16;local dG=(dH-dF)/16;if dF~=8 then return nil,-12 end;if dG>7 then return nil,-13 end;local dK=d_(8)if ee.ReaderBitlenLeft()<0 then return nil,2 end;if(dH*256+dK)%31~=0 then return nil,-14 end;local dI=(dK-dK%32)/32%2;local dJ=(dK-dK%64)/64%4;if dI==1 then if not aP then return nil,-16 end;local dP=d_(8)local dO=d_(8)local dN=d_(8)local dM=d_(8)local aO=dP*16777216+dO*65536+dN*256+dM;if ee.ReaderBitlenLeft()<0 then return nil,2 end;if not aK(aO,aP.adler32)then return nil,-17 end end;local dD,eG=eE(ee)if not dD then return nil,eG end;ee.SkipToByteBoundary()local eL=d_(8)local eM=d_(8)local eN=d_(8)local eO=d_(8)if ee.ReaderBitlenLeft()<0 then return nil,2 end;local eP=eL*16777216+eM*65536+eN*256+eO;local eQ=a:Adler32(dD)if not aK(eP,eQ)then return nil,-15 end;local eI=ee.ReaderBitlenLeft()local eJ=(eI-eI%8)/8;return dD,eJ end;function a:DecompressDeflate(as)local dQ,dR=aV(as)if not dQ then error("Usage: LibDeflate:DecompressDeflate(str): "..dR,2)end;return eH(as)end;function a:DecompressDeflateWithDict(as,aP)local dQ,dR=aV(as,true,aP)if not dQ then error("Usage: LibDeflate:DecompressDeflateWithDict(str, dictionary): "..dR,2)end;return eH(as,aP)end;function a:DecompressZlib(as)local dQ,dR=aV(as)if not dQ then error("Usage: LibDeflate:DecompressZlib(str): "..dR,2)end;return eK(as)end;function a:DecompressZlibWithDict(as,aP)local dQ,dR=aV(as,true,aP)if not dQ then error("Usage: LibDeflate:DecompressZlibWithDict(str, dictionary): "..dR,2)end;return eK(as,aP)end;do E={}for eR=0,143 do E[eR]=8 end;for eR=144,255 do E[eR]=9 end;for eR=256,279 do E[eR]=7 end;for eR=280,287 do E[eR]=8 end;I={}for X=0,31 do I[X]=5 end;local eG;eG,F,D=ef(E,287,9)assert(eG==0)eG,J,H=ef(I,31,5)assert(eG==0)C=bv(F,E,287,9)G=bv(J,I,31,5)end;function a:DecompressGzip(as)local dQ,dR=aV(as)if not dQ then error("Usage: LibDeflate:DecompressGzip(str): "..dR,2)end;if h(string.sub(as,1,1))~=31 or h(string.sub(as,2,2))~=139 then return nil,-1 end;if Y(h(string.sub(as,4,4)),0xE0)~=0 then return nil,-3 end;if h(string.sub(as,3,3))~=8 then return nil,-4 end;local c9=10;if Y(h(string.sub(as,4,4)),4)==4 then c9=c9+h(string.sub(as,11,11))*256+h(string.sub(as,12,12))end;if Y(h(string.sub(as,4,4)),8)==8 then while h(string.sub(as,c9,c9))~=0 do c9=c9+1 end end;if Y(h(string.sub(as,4,4)),16)==16 then while h(string.sub(as,c9,c9))~=0 do c9=c9+1 end end;if Y(h(string.sub(as,4,4)),2)==2 then local eS=h(string.sub(as,c9+1,c9+1))*256+h(string.sub(as,c9,c9))local eT=Y(self:CRC32(string.sub(as,1,c9-1)),0xFFFF)if _(eS,eT)~=0xFFFF then return nil,-5 end;c9=c9+2 end;local a8,dT=eH(string.sub(as,c9+1,-8))if a8==nil then return a8,dT end;local eS=h(string.sub(as,-5,-5))*0x1000000+h(string.sub(as,-6,-6))*0x10000+h(string.sub(as,-7,-7))*256+h(string.sub(as,-8,-8))eS=Z(eS)local eT=self:CRC32(a8)if _(eS,eT)~=0xFFFFFFFF then return nil,-2 end;return a8 end;local eU={["\000"]="%z",["("]="%(",[")"]="%)",["."]="%.",["%"]="%%",["+"]="%+",["-"]="%-",["*"]="%*",["?"]="%?",["["]="%[",["]"]="%]",["^"]="%^",["$"]="%$"}local function eV(as)return as:gsub("([%z%(%)%.%%%+%-%*%?%[%]%^%$])",eU)end;function a:CreateCodec(eW,eX,eY)if type(eW)~="string"or type(eX)~="string"or type(eY)~="string"then error("Usage: LibDeflate:CreateCodec(reserved_chars,".." escape_chars, map_chars):".." All arguments must be string.",2)end;if eX==""then return nil,"No escape characters supplied."end;if#eW<#eY then return nil,"The number of reserved characters must be".." at least as many as the number of mapped chars."end;if eW==""then return nil,"No characters to encode."end;local eZ=eW..eX..eY;local e_={}for K=1,#eZ do local an=h(eZ,K,K)if e_[an]then return nil,"There must be no duplicate characters in the".." concatenation of reserved_chars, escape_chars and".." map_chars."end;e_[an]=true end;local f0={}local f1={}local f2={}local f3={}if#eY>0 then local f4={}local f5={}for K=1,#eY do local f6=l(eW,K,K)local f7=l(eY,K,K)f3[f6]=f7;f2[#f2+1]=f6;f5[f7]=f6;f4[#f4+1]=f7 end;f0[#f0+1]="(["..eV(m(f4)).."])"f1[#f1+1]=f5 end;local f8=1;local f9=l(eX,f8,f8)local fa=0;local f4={}local f5={}for K=1,#eZ do local S=l(eZ,K,K)if not f3[S]then while fa>=256 or e_[fa]do fa=fa+1;if fa>255 then f0[#f0+1]=eV(f9).."(["..eV(m(f4)).."])"f1[#f1+1]=f5;f8=f8+1;f9=l(eX,f8,f8)fa=0;f4={}f5={}if not f9 or f9==""then return nil,"Out of escape characters."end end end;local fb=p[fa]f3[S]=f9 ..fb;f2[#f2+1]=S;f5[fb]=S;f4[#f4+1]=fb;fa=fa+1 end;if K==#eZ then f0[#f0+1]=eV(f9).."(["..eV(m(f4)).."])"f1[#f1+1]=f5 end end;local fc={}local fd="(["..eV(m(f2)).."])"local fe=f3;function fc:Encode(as)if type(as)~="string"then error(("Usage: codec:Encode(str):".." 'str' - string expected got '%s'."):format(type(as)),2)end;return k(as,fd,fe)end;local ff=#f0;local fg="(["..eV(eW).."])"function fc:Decode(as)if type(as)~="string"then error(("Usage: codec:Decode(str):".." 'str' - string expected got '%s'."):format(type(as)),2)end;if j(as,fg)then return nil end;for K=1,ff do as=k(as,f0[K],f1[K])end;return as end;return fc end;local fh;local function fi()return a:CreateCodec("\000","\001","")end;function a:EncodeForWoWAddonChannel(as)if type(as)~="string"then error(("Usage: LibDeflate:EncodeForWoWAddonChannel(str):".." 'str' - string expected got '%s'."):format(type(as)),2)end;if not fh then fh=fi()end;return fh:Encode(as)end;function a:DecodeForWoWAddonChannel(as)if type(as)~="string"then error(("Usage: LibDeflate:DecodeForWoWAddonChannel(str):".." 'str' - string expected got '%s'."):format(type(as)),2)end;if not fh then fh=fi()end;return fh:Decode(as)end;local function fj()local fa={}for K=128,255 do fa[#fa+1]=p[K]end;local eW="sS\000\010\013\124%"..m(fa)return a:CreateCodec(eW,"\029\031","\015\020")end;local fk;function a:EncodeForWoWChatChannel(as)if type(as)~="string"then error(("Usage: LibDeflate:EncodeForWoWChatChannel(str):".." 'str' - string expected got '%s'."):format(type(as)),2)end;if not fk then fk=fj()end;return fk:Encode(as)end;function a:DecodeForWoWChatChannel(as)if type(as)~="string"then error(("Usage: LibDeflate:DecodeForWoWChatChannel(str):".." 'str' - string expected got '%s'."):format(type(as)),2)end;if not fk then fk=fj()end;return fk:Decode(as)end;local fl={[0]="a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","0","1","2","3","4","5","6","7","8","9","(",")"}local fm={[97]=0,[98]=1,[99]=2,[100]=3,[101]=4,[102]=5,[103]=6,[104]=7,[105]=8,[106]=9,[107]=10,[108]=11,[109]=12,[110]=13,[111]=14,[112]=15,[113]=16,[114]=17,[115]=18,[116]=19,[117]=20,[118]=21,[119]=22,[120]=23,[121]=24,[122]=25,[65]=26,[66]=27,[67]=28,[68]=29,[69]=30,[70]=31,[71]=32,[72]=33,[73]=34,[74]=35,[75]=36,[76]=37,[77]=38,[78]=39,[79]=40,[80]=41,[81]=42,[82]=43,[83]=44,[84]=45,[85]=46,[86]=47,[87]=48,[88]=49,[89]=50,[90]=51,[48]=52,[49]=53,[50]=54,[51]=55,[52]=56,[53]=57,[54]=58,[55]=59,[56]=60,[57]=61,[40]=62,[41]=63}function a:EncodeForPrint(as)if type(as)~="string"then error(("Usage: LibDeflate:EncodeForPrint(str):".." 'str' - string expected got '%s'."):format(type(as)),2)end;local at=#as;local fn=at-2;local K=1;local ba={}local b6=0;while K<=fn do local au,av,aw=h(as,K,K+2)K=K+3;local b7=au+av*256+aw*65536;local fo=b7%64;b7=(b7-fo)/64;local fp=b7%64;b7=(b7-fp)/64;local fq=b7%64;local fr=(b7-fq)/64;b6=b6+1;ba[b6]=fl[fo]..fl[fp]..fl[fq]..fl[fr]end;local b7=0;local b8=0;while K<=at do local ad=h(as,K,K)b7=b7+ad*o[b8]b8=b8+8;K=K+1 end;while b8>0 do local ft=b7%64;b6=b6+1;ba[b6]=fl[ft]b7=(b7-ft)/64;b8=b8-6 end;return m(ba)end;function a:DecodeForPrint(as)if type(as)~="string"then error(("Usage: LibDeflate:DecodeForPrint(str):".." 'str' - string expected got '%s'."):format(type(as)),2)end;as=as:gsub("^[%c ]+","")as=as:gsub("[%c ]+$","")local at=#as;if at==1 then return nil end;local fu=at-3;local K=1;local ba={}local b6=0;while K<=fu do local au,av,aw,ax=h(as,K,K+3)au=fm[au]av=fm[av]aw=fm[aw]ax=fm[ax]if not(au and av and aw and ax)then return nil end;K=K+4;local b7=au+av*64+aw*4096+ax*262144;local fo=b7%256;b7=(b7-fo)/256;local fp=b7%256;local fq=(b7-fp)/256;b6=b6+1;ba[b6]=p[fo]..p[fp]..p[fq]end;local b7=0;local b8=0;while K<=at do local ad=h(as,K,K)ad=fm[ad]if not ad then return nil end;b7=b7+ad*o[b8]b8=b8+6;K=K+1 end;while b8>=8 do local an=b7%256;b6=b6+1;ba[b6]=p[an]b7=(b7-an)/256;b8=b8-8 end;return m(ba)end;local function fv()fk=nil;fh=nil end;a.internals={LoadStringToTable=c6,IsValidDictionary=aT,IsEqualAdler32=aK,_byte_to_6bit_char=fl,_6bit_to_byte=fm,InternalClearCache=fv}local fw=_G.arg;local debug=debug;if pcall(require,"LibDeflate")then fw={...}fw[0]="LibDeflate.lua"debug={getinfo=function()return{source="LibDeflate.lua",short_src="LibDeflate.lua"}end}os.exit=function()error()end;io.stderr={write=function(self,fx)printError(fx)end}end;local function fy(fz,bg)if shell then local fz=fs.open(fz,bg)local fA={close=fz.close}if string.find(bg,"r")then fA.read=function()local fA=""local R=fz.read()while R~=nil do fA=fA..string.char(R)R=fz.read()end;fz.close()return fA end end;if string.find(bg,"w")then fA.write=function(fB,as)if type(as)~="string"then error("Not a string: "..textutils.serialize(as),2)end;for ar in string.gmatch(as,".")do fz.write(string.byte(ar))end;fz.close()end end;return fA else return io.open(fz,bg)end end;if io and os and debug and fw then local io=io;local os=os;local fC=debug.getinfo(1)if fC.source==fw[0]or fC.short_src==fw[0]then local dX;local fD;local K=1;local eG;local fE=0;local fF=false;local cb;local dt;local aP;while fw[K]do local Q=fw[K]if Q=="-h"then print(a._COPYRIGHT.."\nUsage: lua LibDeflate.lua [OPTION] [INPUT] [OUTPUT]\n".."  -0    store only. no compression.\n".."  -1    fastest compression.\n".."  -9    slowest and best compression.\n".."  -d    do decompression instead of compression.\n".."  --dict <filename> specify the file that contains".." the entire preset dictionary.\n".."  --gzip  use gzip format instead of raw deflate.\n".."  -h    give this help.\n".."  --strategy <fixed/huffman_only/dynamic>".." specify a special compression strategy.\n".."  -v    print the version and copyright info.\n".."  --zlib  use zlib format instead of raw deflate.\n")os.exit(0)elseif Q=="-v"then print(a._COPYRIGHT)os.exit(0)elseif Q:find("^%-[0-9]$")then cb=tonumber(Q:sub(2,2))elseif Q=="-d"then fF=true elseif Q=="--dict"then K=K+1;local fG=fw[K]if not fG then io.stderr:write("You must speicify the dict filename")os.exit(1)end;local fH,fI=fy(fG,"rb")if not fH then io.stderr:write("LibDeflate: Cannot read the dictionary file '%s': %s":format(fG,fI))os.exit(1)end;local fJ=fH:read("*all")fH:close()aP=a:CreateDictionary(fJ,#fJ,a:Adler32(fJ))elseif Q=="--gzip"then fE=2 elseif Q=="--strategy"then K=K+1;dt=fw[K]elseif Q=="--zlib"then fE=1 elseif Q:find("^%-")then io.stderr:write("LibDeflate: Invalid argument: %s":format(Q))os.exit(1)else if not dX then dX,eG=fy(Q,"rb")if not dX then io.stderr:write("LibDeflate: Cannot read the file '%s': %s":format(Q,tostring(eG)))os.exit(1)end elseif not fD then fD,eG=fy(Q,"wb")if not fD then io.stderr:write("LibDeflate: Cannot write the file '%s': %s":format(Q,tostring(eG)))os.exit(1)end end end;K=K+1 end;if not dX or not fD then io.stderr:write("LibDeflate:".." You must specify both input and output files.")os.exit(1)end;local fK=dX:read("*all")local aY={level=cb,strategy=dt}local fL;if not fF then if fE==0 then if not aP then fL=a:CompressDeflate(fK,aY)else fL=a:CompressDeflateWithDict(fK,aP,aY)end elseif fE==1 then if not aP then fL=a:CompressZlib(fK,aY)else fL=a:CompressZlibWithDict(fK,aP,aY)end elseif fE==2 then fL=a:CompressGzip(fK,aY)end else if fE==0 then if not aP then fL=a:DecompressDeflate(fK)else fL=a:DecompressDeflateWithDict(fK,aP)end elseif fE==1 then if not aP then fL=a:DecompressZlib(fK)else fL=a:DecompressZlibWithDict(fK,aP)end elseif fE==2 then fL=a:DecompressGzip(fK)end end;if not fL then io.stderr:write("LibDeflate: Decompress fails.")os.exit(1)end;fD:write(fL)if dX and dX~=io.stdin then dX:close()end;if fD and fD~=io.stdout then fD:close()end;io.stderr:write("Successfully writes %d bytes":format(fL:len()))os.exit(0)end end;return a