--[[
Coroutine Scheduler with:
- Event/wait system: coroutines can wait for a named event, and you can signal events to resume them
- Ability to stop/cancel coroutines by handle
- Argument passing: you can pass arguments to coroutine resumes (e.g., when signaling an event)

Features:
- Priorities supported (see previous examples)
- No timers or simulated time; coroutines yield to give up control and can wait for events

Usage:
- scheduler:spawn(func, priority, ...) â†’ returns a handle you can use to cancel
- Use Scheduler.wait(event_name) in a coroutine to wait for an event
- Use scheduler:signal(event_name, ...) to resume all coroutines waiting for that event, passing arguments to their resumes
- Use scheduler:cancel(handle) to stop a coroutine
- Arguments to coroutine.resume are always passed (including on event signal)

]]

local Scheduler = {}
Scheduler.__index = Scheduler

function Scheduler.new()
    local self = setmetatable({}, Scheduler)
    self.queue = {}
    self.waiting = {}     -- event_name -> { {co=..., args=..., priority=..., handle=...}, ... }
    self.handles = {}     -- handle -> {co=..., args=..., priority=..., handle=..., status="active"/"cancelled"}
    self.next_handle = 1
    return self
end

-- Spawn a coroutine with a given priority (default 1), returns a handle
function Scheduler:spawn(func, priority, ...)
    priority = priority or 1
    local co = coroutine.create(func)
    local handle = self.next_handle
    self.next_handle = self.next_handle + 1
    local task = {co = co, args = {...}, priority = priority, handle = handle, status="active"}
    self.handles[handle] = task
    self:insert_with_priority(task)
    return handle
end

-- Insert task (with priority count) into the run queue if it's active
function Scheduler:insert_with_priority(task)
    if task.status == "cancelled" then return end
    for _ = 1, task.priority or 1 do
        table.insert(self.queue, task)
    end
end

-- Wait for a named event (to be used inside a coroutine)
function Scheduler.wait(event_name)
    return coroutine.yield({"wait", event_name})
end

-- Signal an event and resume all waiting coroutines, passing ... as resume arguments
function Scheduler:signal(event_name, ...)
    local waiters = self.waiting[event_name]
    if waiters then
        for _, task in ipairs(waiters) do
            if task.status ~= "cancelled" then
                -- Pass the signaled arguments as resume arguments
                task.args = {...}
                self:insert_with_priority(task)
            end
        end
        self.waiting[event_name] = nil
    end
end

-- Cancel a coroutine by handle
function Scheduler:cancel(handle)
    local task = self.handles[handle]
    if task then
        task.status = "cancelled"
        -- Remove from waiting list if present
        for event, waiters in pairs(self.waiting) do
            for i = #waiters, 1, -1 do
                if waiters[i].handle == handle then
                    table.remove(waiters, i)
                end
            end
        end
        -- Note: For simplicity, tasks already in self.queue may still run this tick, but will be dropped after.
        -- To fully purge, you'd also scan/remove from self.queue here.
    end
end

function Scheduler:run()
    while #self.queue > 0 do
        local task = table.remove(self.queue, 1)
        if task.status ~= "cancelled" then
            local co, args, priority, handle = task.co, task.args, task.priority, task.handle
            local status, res = coroutine.resume(co, table.unpack(args))
            task.args = {} -- reset args for next resume
            if not status then
                print("Coroutine error:", res)
                self:cancel(handle)
            elseif coroutine.status(co) ~= "dead" then
                if type(res) == "table" and res[1] == "wait" then
                    local event_name = res[2]
                    self.waiting[event_name] = self.waiting[event_name] or {}
                    table.insert(self.waiting[event_name], task)
                else
                    self:insert_with_priority(task)
                end
            else
                self:cancel(handle)
            end
        end
    end
end

-- Example usage:
local scheduler = Scheduler.new()

local h1 = scheduler:spawn(function()
    print("A: waiting for foo")
    local v = Scheduler.wait("foo")
    print("A: got event foo with value:", v)
end, 2)

local h2 = scheduler:spawn(function()
    print("B: doing some work")
    coroutine.yield()
    print("B: waiting for bar")
    local x, y = Scheduler.wait("bar")
    print("B: got event bar with values:", x, y)
end, 1)

local h3 = scheduler:spawn(function()
    print("C: will be cancelled")
    Scheduler.wait("foo")
    print("C: should never print this!")
end, 1)

-- Cancel C before it gets event
scheduler:cancel(h3)

-- Run one tick (A and B run, both yield to wait for events)
scheduler:run()

print("Signaling events...")

scheduler:signal("foo", 42)
scheduler:signal("bar", "hello", "world")

-- Resume for events
scheduler:run()

--[[ Output:
A: waiting for foo
B: doing some work
B: waiting for bar
Signaling events...
A: got event foo with value:   42
B: got event bar with values:  hello   world
]]